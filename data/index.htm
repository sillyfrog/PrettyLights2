<!DOCTYPE html>
<html lang="en">
<!--
To test, see webdev/app.py
v1.1.1
-->

<head>
  <meta charset="utf-8">
  <title>Pretty Lights!</title>

  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"
    integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj"
    crossorigin="anonymous"></script>

  <link rel="stylesheet" type="text/css"
    href="https://cdn.datatables.net/v/bs4/dt-1.10.21/sl-1.3.1/datatables.min.css" />
  <script type="text/javascript" src="https://cdn.datatables.net/v/bs4/dt-1.10.21/sl-1.3.1/datatables.min.js"></script>


  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"
    integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">

  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
    integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
    crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"
    integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI"
    crossorigin="anonymous"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-slider/10.6.0/bootstrap-slider.min.js"
    integrity="sha256-G5ZTzV4wJSLf9AuZ3wMEJVZDp1MumYGrEw+JsAGHRXI=" crossorigin="anonymous"></script>
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-slider/10.6.0/css/bootstrap-slider.min.css"
    integrity="sha256-D25WHQReXOtVfJZu6lFdpu3ZN4kvVA7/+Af5mPjYlbw=" crossorigin="anonymous" />

  <script src="https://d3js.org/d3.v5.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jscolor/2.0.4/jscolor.min.js"></script>
  <style>
    body {
      padding: 10px;
    }

    .slider.slider-horizontal {
      width: 110px;
      border-radius: 4px;
    }

    .inputfield {
      border-bottom: 1px solid #ddd;
      min-width: 10em;
      min-height: 1em;
      display: inline-block;
    }

    .pattern-row {
      margin-top: 5px;
    }

    .floater {
      position: fixed;
      top: 70px;
      right: 10px;
      z-index: 10;
      min-width: 200px;
      background: #eee;
      border-radius: 5px;
      border: 1px solid black;
      padding: 3px;
    }

    .pattern>canvas {
      width: 100%;
      height: 30px;
    }

    div.pattern {
      position: relative;
      margin-top: 8px;
      border: 1px solid black;
      height: 32px;
    }

    .timepointer {
      position: absolute;
      margin-left: -4.5px;
    }

    .btn-stacking>button {
      margin-bottom: 3px;
    }
  </style>
</head>

<body onload="checkReload(); loadData(); setupPage(); runtest();">
  <div id="dProgressArea" class="collapse show floater">
    <h6 id="hProgressTitle">Loading</h6>
    <div class="progress">
      <div id="dOverallProgressBar" class="progress-bar bg-success" role="progressbar" style="width: 0%"
        aria-valuemin="0" aria-valuemax="100"></div>
    </div>
    <h6 id="hProgressSubTitle">...</h6>
    <div class="progress">
      <div id="dProgressBar" class="progress-bar" role="progressbar" style="width: 0%" aria-valuemin="0"
        aria-valuemax="100"></div>
    </div>
  </div>

  <nav class="navbar navbar-expand-lg navbar-dark bg-dark sticky-top">
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
      aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav mr-auto">
        <li class="nav-item">
          <a href="#aRGB" class="nav-link">RGB Patterns</a>
        </li>
        <li class="nav-item">
          <a href="#aPWM" class="nav-link">PWM Patterns</a>
        </li>
        <li class="nav-item">
          <a href="#RGB" class="nav-link">RGB LEDs</a>
        </li>
        <li class="nav-item">
          <a href="#PWM" class="nav-link">PWM LEDs</a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown"
            aria-haspopup="true" aria-expanded="false">
            More
          </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            <button type="button" class="dropdown-item" data-toggle="modal" data-target="#modalEditConfig">
              Edit Hardware Configuration
            </button>
            <button onclick="saveAllChanges();" class="dropdown-item">Save Changes</button>
            <div class="dropdown-divider"></div>
            <button onclick="doTestMode(1);" class="dropdown-item" id="testmode1">Enter Test Mode 1</button>
            <div class="dropdown-divider"></div>
            <button onclick="downloadAllPatternImage(RGB);" class="dropdown-item">Download All RGB Patterns
              Image</button>
            <button onclick="downloadAllPatternImage(PWM);" class="dropdown-item">Download All PWM Patterns
              Image</button>
            <button onclick="downloadFullBackup();" class="dropdown-item">Download Complete Backup</button>
            <button onclick="$(modalBulkUpload).modal('show');" class="dropdown-item">Bulk Upload</button>
          </div>
        </li>
      </ul>
    </div>
    <button onclick="doTestMode(0);" class="btn btn-outline-danger ml-1" style="display: none;" id="btnTestModeOff">Test
      Mode</button>
    <div class="btn-group ml-1" id="btnGroupClickAssign" style="display: none;">
      <button class="btn btn-secondary" type="button" id="btnClickAssign" onclick="stopAssignPattern();">
        Click to Assign...
      </button>
      <button type="button" class="btn btn-secondary dropdown-toggle dropdown-toggle-split" data-toggle="dropdown"
        aria-haspopup="true" aria-expanded="false">
        <span class="sr-only">Toggle Dropdown</span>
      </button>
      <div class="dropdown-menu dropdown-menu-right" aria-labelledby="btnClickAssignPattern" style="min-width: 20rem;">
        <form class="px-4 py-3" onsubmit="return false;">
          <div class="form-check">
            <input class="form-check-input" type="radio" name="rdoPatternAssignOrder" id="rdoPatternAssignSequential"
              value="sequential" checked>
            <label class="form-check-label" for="rdoPatternAssignSequential">
              Sequential
            </label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="radio" name="rdoPatternAssignOrder" id="rdoPatternAssignSame"
              value="same">
            <label class="form-check-label" for="rdoPatternAssignSame">
              Same
            </label>
          </div>
          <button class="btn btn-primary btn-sm" onclick="changeAssignPattern(1);">Next Pattern</button>
          <button class="btn btn-primary btn-sm" onclick="changeAssignPattern(-1);">Back Pattern</button>
        </form>
        <span class="dropdown-item-text"><small>Click on the LED pattern link to quickly assign the same or sequential
            patterns to LED's</small> </span>

      </div>
    </div>
    <button onclick="bulkEdit(RGB);" class="btn btn-outline-info ml-1" style="display: none;" id="btnBulkEditrgb">Edit
      RGB x<span id="spnBulkEditCountrgb"></span></button>
    <button onclick="bulkEdit(PWM);" class="btn btn-outline-info ml-1" style="display: none;" id="btnBulkEditpwm">Edit
      PWM x<span id="spnBulkEditCountpwm"></span></button>
    <button onclick="saveAllChanges();" class="btn btn-outline-info ml-1" style="display: none;"
      id="btnSaveChanges">Save Changes</button>
  </nav>
  <div class="container">
    <span id="spanAlerts"></span>
    <h1>
      Pretty Lights: <span id="title" data-editable onchange="titleUpdated(this);" class="inputfield">LEGO
        Lights!</span>
    </h1>
    <div class="modal fade show" id="modalEditPattern" tabindex="-1" role="dialog" aria-hidden="true">
      <div class="modal-dialog modal-xl" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">Edit Pattern</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span aria-hidden="true">&times;</span>
            </button>
          </div>
          <div class="modal-body">
            <form>
              <div class="form-group row">
                <label class="col col-form-label">Pattern Title:</label>
                <div class="col">
                  <input class="form-control store-value" id="inpPatternTitle" required>
                </div>
              </div>
              <div class="form-group row">
                <label class="col col-form-label">Pattern Type:</label>
                <div class="col">
                  <select class="form-control" onchange="changePatternStyle();" id="selPatternStyle">
                    <option value="Static">Static</option>
                    <option value="Fade">Fade</option>
                    <option value="Flash">Flash</option>
                    <option value="Custom">Custom</option>
                  </select>
                </div>
              </div>
            </form>

            <div class="card mb-4 shadow-sm card-edit" id="cardEditStatic">
              <div class="card-header">
                <h4 class="my-0 font-weight-normal">Static Configuration</h4>
              </div>
              <div class="card-body">
                <div class="form-group row">
                  <label class="col col-form-label">Color:</label>
                  <div class="col" data-colorcontrol="inpStaticColor">
                  </div>
                </div>
                <div class="row">
                  <div class="col">
                    <small class="text-muted">Don't use Static patterns for setting an LED color, instead use the
                      default color and remove the patten.
                      The Static type allows the creation of a base pattern than can then be downloaded and used as part
                      of a custom pattern.
                    </small>
                  </div>
                </div>
              </div>
            </div>

            <div class="card mb-4 shadow-sm card-edit" id="cardEditFlash">
              <div class="card-header">
                <h4 class="my-0 font-weight-normal">Flashing Configuration</h4>
              </div>
              <div class="card-body">
                <div class="form-group row">
                  <label class="col col-form-label">Flashes per cycle:</label>
                  <div class="col">
                    <input type="number" step="any" class="form-control store-value" id="inpFlashesPerCycle" value="5"
                      required>
                  </div>
                </div>
                <div class="form-group row">
                  <label class="col col-form-label">% on time:</label>
                  <div class="col">
                    <input type="number" step="any" class="form-control store-value" id="inpFlashOnTime" value="50"
                      required>
                  </div>
                </div>
                <div class="form-group row">
                  <label class="col col-form-label">Offset (seconds)</label>
                  <div class="col">
                    <input type="number" step="any" class="form-control store-value" id="inpFlashOffset" value="0"
                      required>
                    <small class="form-text text-muted">The offset from 0 seconds for when to start the cycle.</small>
                  </div>
                </div>
                <div class="form-group row">
                  <label class="col col-form-label">Off color:</label>
                  <div class="col" data-colorcontrol="inpFlashOffColor">
                  </div>
                </div>
                <div class="form-group row">
                  <label class="col col-form-label">On color:</label>
                  <div class="col" data-colorcontrol="inpFlashOnColor">
                  </div>
                </div>
              </div>
            </div>

            <div class="card mb-4 shadow-sm card-edit" id="cardEditFade">
              <div class="card-header">
                <h4 class="my-0 font-weight-normal">Fading Configuration</h4>
              </div>
              <div class="card-body">
                <div class="form-group row">
                  <label class="col col-form-label">Fades per cycle:</label>
                  <div class="col">
                    <input type="number" step="any" class="form-control store-value" id="inpFadesPerCycle" value="5"
                      required>
                  </div>
                </div>
                <div class="form-group row">
                  <label class="col col-form-label">Start color:</label>
                  <div class="col" data-colorcontrol="inpFadeStartColor">
                  </div>
                </div>
                <div class="form-group row">
                  <label class="col col-form-label">End color:</label>
                  <div class="col" data-colorcontrol="inpFadeEndColor">
                  </div>
                </div>
              </div>
            </div>

            <div class="card mb-4 shadow-sm card-edit" id="cardEditCustom">
              <div class="card-header">
                <h4 class="my-0 font-weight-normal">Custom Configuration</h4>
              </div>
              <div class="card-body">
                <div class="form-group row">
                  <label class="col col-form-label">Download</label>
                  <div class="col btn-stacking">
                    <button class="btn btn-primary" onclick="downloadPatternImage();">Download as PNG</button>
                    <br>
                    <button class="btn btn-primary" onclick="downloadPatternJSON('packed');"
                      id="editDownloadJsonPacked">Download as JSON (packed array)</button>
                    <br class="rgb-only">
                    <button class="btn btn-primary rgb-only" onclick="downloadPatternJSON('arrays');"
                      id="editDownloadJsonArrays">Download as JSON (array of arrays)</button>
                  </div>
                </div>
                <div class="form-group row">
                  <label class="col col-form-label">Upload Pattern</label>
                  <div class="col">
                    <input type="file" class="form-control-file" id="fileCustomPattern"
                      onchange="updateSelectFileType(this);">
                    <button class="btn btn-primary" onclick="uploadPatternFile();"
                      id="btnUploadCustomFile">Upload</button>
                    <div id="divUploadFileType"></div>
                  </div>
                </div>
              </div>
            </div>

            <div class="row">
              <div class="col">
                <div style="width:30px; height: 30px; background: black; border: 1px solid black;" id="divPlay">&nbsp;
                </div>
              </div>
              <div class="col text-right"><button onclick="playPattern();" class="btn btn-primary" id="btnEditPlay">
                </button></div>
            </div>
            <div class="pattern" id="divPatternEdit"></div>


          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            <button type="button" class="btn btn-primary" onclick="patternApply();">Apply changes</button>
          </div>
        </div>
      </div>
    </div>

    <div class="modal fade show" id="modalBulkUpload" tabindex="-1" role="dialog" aria-hidden="true">
      <div class="modal-dialog modal-xl" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">Bulk Upload</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span aria-hidden="true">&times;</span>
            </button>
          </div>
          <div class="modal-body">
            <div class="form-group row">
              <label class="col col-form-label">Patterns to update:</label>
              <div class="col">
                <select class="form-control" id="selBulkUploadType" onchange="updateBulkDimensions();">
                  <option value="rgb">RGB</option>
                  <option value="pwm">PWM</option>
                  <option value="backup">Backup</option>
                </select>
              </div>
            </div>
            <div class="form-group row" id="rowBulkUploadDimensions">
              <label class="col col-form-label">Image Dimensions</label>
              <div class="col">
                <span id="spnBulkUploadWide">100</span>px wide &times; <span id="spnBulkUploadHigh">100</span>px high
              </div>
            </div>
            <div class="form-group row">
              <label class="col col-form-label">Upload Patterns</label>
              <div class="col">
                <input type="file" class="form-control-file" id="fileBulkPatterns">
                <div id="divBulkUploadErrors" class="text-danger"></div>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            <button type="button" class="btn btn-primary" onclick="uploadBulkFile();">Upload</button>
          </div>
        </div>
      </div>
    </div>


    <table id="testtable"></table>

    <p>&nbsp;</p>
    <h3 id="aRGB">RGB Patterns</h3>
    <div id="divrgbPatterns"></div>

    <p>&nbsp;</p>
    <h3 id="aPWM">PWM Patterns</h3>
    <div id="divpwmPatterns"></div>

    <p>&nbsp;</p>
    <h3 id="RGB">RGB LED's</h3>
    <table class="table table-striped " id="rgbtable" data-type="rgb">
      <thead>
        <tr>
          <th>Select</th>
          <th>LED</th>
          <th>Default Color</th>
          <th>Pattern</th>
          <th>Description</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody id="rgbbody">
      </tbody>
    </table>

    <p>&nbsp;</p>
    <h3 id="PWM">PWM LED's</h3>
    <table class="table table-striped " id="pwmtable" data-type="pwm">
      <thead>
        <tr>
          <th>Select</th>
          <th>LED</th>
          <th>Default Color</th>
          <th>Pattern</th>
          <th>Description</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody id="pwmbody">
      </tbody>
    </table>

    <p>&nbsp;</p>
    <div class="card mb-4 shadow-sm">
      <div class="card-header">
        <h4 class="my-0 font-weight-normal">Status</h4>
      </div>
      <div class="card-body">
        <table class="table">
          <tr>
            <th>Version</th>
            <td id="version"></td>
          </tr>
          <tr>
            <th>Extras Version</th>
            <td id="extrasversion"></td>
          </tr>
          <tr>
            <th>Free Heap</th>
            <td id="heap"></td>
          </tr>
          <tr>
            <th>SSID</th>
            <td id="ssid"></td>
          </tr>
          <tr>
            <th>Total Storage</th>
            <td id="total"></td>
          </tr>
          <tr>
            <th>Used Storage</th>
            <td id="used"></td>
          </tr>
          <tr>
            <th>Free Storage</th>
            <td id="free"></td>
          </tr>
          <tr>
            <th>Hardware Flash Size</th>
            <td id="flashrealsize"></td>
          </tr>
        </table>
      </div>
    </div>
  </div>
  <div>
  </div>
  <div class="modal fade show" id="modalEditConfig" tabindex="-1" role="dialog" aria-hidden="true">
    <div class="modal-dialog modal-lg" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <h4 class="modal-title">LED Hardware Configuration</h4>
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>
        <div class="modal-body">
          <h5>Number of Patterns</h5>
          <div class="form-group row">
            <label class="col col-form-label">Number of RGB Patterns</label>
            <div class="col">
              <input type="number" min=1 max=50 class="form-control" id="inpNumRGBPatterns" data-type="rgb"
                onchange="hwsetupPatternChange(this);">
            </div>
          </div>
          <div class="form-group row">
            <label class="col col-form-label">Number of PWM Patterns</label>
            <div class="col">
              <input type="number" min=1 max=50 class="form-control" id="inpNumPWMPatterns" data-type="pwm"
                onchange="hwsetupPatternChange(this);">
            </div>
          </div>
          <br>
          <h5>RGB LED strips</h5>
          <div data-ledconfig="rgb" data-maxdevices="3" data-maxperdevice="60"></div>
          <small class="form-text text-muted">Number of LED Strips, and number of LED's per strip.</small>
          <br>
          <h5>PWM LED Boards</h5>
          <div data-ledconfig="pwm" data-maxdevices="2" data-maxperdevice="4"></div>
          <small class="form-text text-muted">Number of PWM channels, and number boards connected per
            channel.</small>
          <br>
          <h5>Frame Rate &amp; Duration</h5>
          <div class="form-group row">
            <label class="col col-form-label">Total number of frames:</label>
            <div class="col">
              <input type="number" min=50 max=50000 class="form-control" id="inpFramesCount" data-item="count"
                onchange="hwsetupFramesChange(this);">
            </div>
          </div>
          <div class="form-group row">
            <label class="col col-form-label">Frames per second:</label>
            <div class="col">
              <input type="number" min=1 max=30 class="form-control" id="inpFrameRate" data-item="framespersec"
                onchange="hwsetupFramesChange(this);">
            </div>
          </div>
          <div class="form-group row">
            <label class="col col-form-label">Duration for all frames:</label>
            <div class="col">
              <input type="text" readonly class="form-control-plaintext" id="inpFramesDuration" value="...">
            </div>
          </div>
          <h5>Flash Storage Usage</h5>
          <div class="form-group row">
            <label class="col col-form-label">Total Approximate Storage Usage:</label>
            <div class="col">
              <input type="text" readonly class="form-control-plaintext" id="inpTotalStorage" value="...">
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            <button id="btnSaveHwsetup" class="btn btn-primary" style="display:none;" onclick="saveHwsetup();">Save,
              Reboot &amp; Reload <div class="spinner-border spinner-border-sm" role="status" id="spnrSaveHwsetup"
                style="display: none;">
                <span class="sr-only">Waiting...</span>
              </div></button>
          </div>
        </div>
      </div>
    </div>
  </div>


  <div class="modal fade" id="modalBulkEditLED" tabindex="-1" role="dialog" aria-hidden="true">
    <div class="modal-dialog modal-lg" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <h4 class="modal-title">Bulk Edit <span id="spnBulkEditLedStats"></span> LED's</h4>
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>
        <div class="modal-body">
          <div class="form-group row">
            <label class="col col-form-label">Default Color</label>
            <div class="col" data-colorcontrol="inpDefaultColor"> </div>
          </div>
          <div class="form-group row">
            <label class="col col-form-label">Assigned Pattern</label>
            <div class="col">
              <select id="selBulkPattern"></select>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            <button id="btnSaveBulkEdit" class="btn btn-primary" onclick="saveBulkEdit();">Save</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div style="display: none;">
    <canvas id="tmpcanvas"></canvas>
    <a id="downloadlink" target="_blank" style="display: none;">download</a>
  </div>

  <script>
    const FETCH_NO_CACHE = { cache: "reload" };
    // For HTML debugging, always use the browser cache
    // const FETCH_NO_CACHE = { cache: "force-cache" };
    const JSCOLOR_DEFAULTS = { "zIndex": 1060 };
    const RGB = "rgb";
    const PWM = "pwm";

    const PLAY_ICON = '<svg style="height: 14px;" viewBox="0 0 448 512"> <path fill="currentColor" d="M424.4 214.7L72.4 6.6C43.8-10.3 0 6.1 0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1 0-82.6z" class=""></path> </svg>';
    const PAUSE_ICON = '<svg style="height: 14px;" viewBox="0 0 448 512"><path fill="currentColor" d="M144 479H48c-26.5 0-48-21.5-48-48V79c0-26.5 21.5-48 48-48h96c26.5 0 48 21.5 48 48v352c0 26.5-21.5 48-48 48zm304-48V79c0-26.5-21.5-48-48-48h-96c-26.5 0-48 21.5-48 48v352c0 26.5 21.5 48 48 48h96c26.5 0 48-21.5 48-48z" class=""></path></svg>';

    const TIMEPOINTER_PNG = " data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAeCAYAAAD+QjQzAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TS4tWHCwi4pChOlkQFXHUKhShQqkVWnUwufQLmjQkKS6OgmvBwY/FqoOLs64OroIg+AHi5Oik6CIl/i8ptIjx4Lgf7+497t4BQqPCVLNrHFA1y0gn4mI2tyoGXxHAAILoQUhipj6XSiXhOb7u4ePrXYxneZ/7c/QqeZMBPpF4lumGRbxBPL1p6Zz3iSOsJCnE58RjBl2Q+JHrsstvnIsOCzwzYmTS88QRYrHYwXIHs5KhEk8RRxVVo3wh67LCeYuzWqmx1j35C8N5bWWZ6zSHkcAilpCCCBk1lFGBhRitGikm0rQf9/APOf4UuWRylcHIsYAqVEiOH/wPfndrFiYn3KRwHAi82PbHCBDcBZp12/4+tu3mCeB/Bq60tr/aAGY+Sa+3tegR0LcNXFy3NXkPuNwBBp90yZAcyU9TKBSA9zP6phzQfwt0r7m9tfZx+gBkqKvkDXBwCIwWKXvd492hzt7+PdPq7wfuz3JytGv6iQAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB+QFFhY2Fpnwj+EAAABTSURBVDjL7ZOxDcAwDMPovtSf/FP6U29ilwQNPARdukWABtmENqEyuQGqbb4ffNCGNrSh36Asvzf3leZY73BfcaqEmsAZEbUJ9QJuakO12qKHpR4lQEmK3QecOwAAAABJRU5ErkJggg==";

    // Frames kept in each file, each file size will increase based on the number of patterns
    // This MUST match the same constant in main.cpp
    const FRAMES_PER_FILE = 25;

    // The active ESP config, including version, memory etc. Read only
    var activeconfig = null;
    // The hardware setup, number of strips etc
    var hwsetup = null;
    // Metadata required by the browser only, this is not used by the ESP
    var metadata = null;
    // The default colors and pattern assignments
    var ledAssignments = null
    // True if there were any errors running saveAllChanges();
    var saveallerror;

    // Extra state changes that need to be applied
    var extraStateChanges = {};

    // Number of LED's per PWM board
    const LED_PER_BOARD = 24
    // Underlying led datatable objects
    var ledtable = {};

    class RgbPixels {
      constructor(patterncount, frames, framesperfile) {
        this._type = RGB;
        this._curFileId = 0;
        this._patterncount = patterncount;
        this._framecount = frames;
        this._framesperfile = framesperfile;
        // The original data, each entry links to a FILE
        this._srcdata = [];
        // The data that is updated, each entry is a PATTERN
        this._livedata = [];
        this._unitsperframe = 3;
        this._filebytes = this._framesperfile * this._patterncount * this._unitsperframe;
        this._IntArray = Uint8Array;
        this._fileCount = this._framecount / this._framesperfile;
      }

      getForJSON() {
        // Returns the Live data to allow saving to JSON (requires usage of the jsonReplacer)
        return this._livedata;
      }

      setForJSON(data) {
        // Sets the data to _livedata that was extracted by getForJSON
        this._livedata = data;
      }

      _blankPixel() {
        // Returns a new instance of a "blank" pixel, overridden in child classes
        return new Uint8Array(this._unitsperframe);
      }

      getPattern(patternid) {
        // Returns the pattern by reference so it can be updated in place 
        return this._livedata[patternid];
      }

      getInfo(patternid) {
        // Returns the info object in places to allow updating by reference
        var info = metadata[this._type][patternid];
        if (!info) {
          info = {
            "title": "Unnamed",
            "def": {}
          }
          metadata[this._type][patternid] = info;
        }
        return info;
      }

      getCountingArray() {
        // Returns an array, with each value the index of a puzzle
        // For use by d3
        var ret = [];
        for (var p = 0; p < this._patterncount; p++) {
          ret[p] = p;
        }
        return ret;
      }

      setFileBuf(filebuf, id) {
        var srcdata = new this._IntArray(filebuf);
        var px;
        if (srcdata.length == 0) {
          return;
        }
        // Now copy over the data, this will handle the case were the local data has been resized
        // A resize is assumed to be a change in the number of patterns
        var arraypatterns = srcdata.length / this._unitsperframe / this._framesperfile;
        var looppatterns = this._patterncount;
        if (arraypatterns < looppatterns) looppatterns = arraypatterns;

        var fileframeoffset = id * this._framesperfile;
        for (var f = 0; f < this._framesperfile; f++) {
          for (var p = 0; p < looppatterns; p++) {
            // var liveframestart = (f + fileframeoffset);
            var srcframestart = this._unitsperframe * (p + f * arraypatterns);
            // console.log("pat", p, "frame", f, "src start", srcframestart, "dst start", liveframestart);
            if (this._unitsperframe > 1) {
              // Use "slice" as it gives a copy, subarray overlays the same underlying buffer
              px = srcdata.slice(srcframestart, srcframestart + this._unitsperframe);
            } else {
              px = srcdata[srcframestart];
            }
            this._livedata[p][f + fileframeoffset] = px;
          }
        }
        this._srcdata[id] = srcdata;
      }

      _getFilePath(type, id) {
        var dirid = Math.floor(id / 10).toFixed(0).padStart(2, "0");
        var fileid = id.toFixed(0).padStart(4, "0");
        var filepath = type + dirid + "/frames" + fileid + ".dat"
        return filepath;
      }

      // JavaScript is a horror "this" does not always work... 
      loadNextFile(me) {
        if (me._curFileId >= me._fileCount) {
          // Nothing left to process, return
          return Promise.resolve();
        }
        var filepath = me._getFilePath(me._type, me._curFileId);
        return fetch(filepath, FETCH_NO_CACHE)
          .then(function (response) {
            return response.arrayBuffer();
          })
          .then(function (buf) {
            var start = new Date();
            me.setFileBuf(buf, me._curFileId);
            var end = new Date();
            me._curFileId++;
            // console.log("Time to process file:", me._curFileId, fileCount, end - start);
            if (me._allFilesProgressCallback) {
              me._allFilesProgressCallback(me._curFileId, me._fileCount);
            }
            return me.loadNextFile(me);
          });
      }

      initPixels() {
        for (var p = 0; p < this._patterncount; p++) {
          this._livedata[p] = new Array(this._framecount);
          for (var f = 0; f < this._framecount; f++) {
            this._livedata[p][f] = this._blankPixel();
          }
        }
      }

      async loadFiles(progressCallback) {
        this._curFileId = 0;
        this._allFilesProgressCallback = progressCallback;
        // Init the _livedata
        this._livedata = [];
        this.initPixels();
        return await this.loadNextFile(this);
      }

      async saveNextFile(me, newFileData) {
        if (me._fileSaveIds.length == 0) {
          // Nothing left to process, return
          return Promise.resolve();
        }
        // See if the file data matches
        if (me._srcdata[me._fileSaveIds[0]] && newFileData[me._fileSaveIds[0]].length === me._srcdata[me._fileSaveIds[0]].length) {
          // Original file and current are the same length, check the bytes
          var identical = true;
          for (var i = 0; i < newFileData[me._fileSaveIds[0]].length; i++) {
            if (newFileData[me._fileSaveIds[0]][i] !== me._srcdata[me._fileSaveIds[0]][i]) {
              identical = false;
              break;
            }
          }
          if (identical) {
            console.log("newFileData is identical:", me._type, me._fileSaveIds[0]);
            me._fileSaveIds.shift();
            if (me._allFilesProgressCallback) {
              me._allFilesProgressCallback(me._fileCount - me._fileSaveIds.length, me._fileCount);
            }
            return me.saveNextFile(me, newFileData);
          }
        }

        var filepath = me._getFilePath(me._type, me._fileSaveIds[0]);
        var formData = new FormData();
        formData.append('data', new Blob([newFileData[me._fileSaveIds[0]]]), filepath);
        return fetch('edit', {
          method: "POST",
          body: formData
        })
          .then(async function (resp) {
            if (resp.ok) {
              // Things went OK, update the srcfile cache, remove the top element, and save the next
              me._srcdata[me._fileSaveIds[0]] = newFileData[me._fileSaveIds[0]];
              me._fileSaveIds.shift();
              if (me._allFilesProgressCallback) {
                me._allFilesProgressCallback(me._fileCount - me._fileSaveIds.length, me._fileCount);
              }
              return me.saveNextFile(me, newFileData);
            } else {
              // There was some error - log it and try again in a second
              console.error("Error saving file:", resp);
              showAlert("Error saving pattern file (" + me._fileSaveIds[0] + "): " + resp.statusText, "savepattern");
              await sleep(1000);
              return me.saveNextFile(me, newFileData);
            }
          })
          .catch(async function (error) {
            console.error("Major Error:", error);
            showAlert("Network error saving pattern file (" + me._fileSaveIds[0] + "): " + error, "savepattern");
            await sleep(1000);
            return me.saveNextFile(me, newFileData);
          });
      }

      async saveFiles(progressCallback) {
        // Saves all of the CHANGED files to flash

        // Populate a local cache of what the new files look like
        var newFileData = new Array(this._fileCount);
        this._fileSaveIds = new Array();
        this._allFilesProgressCallback = progressCallback;
        for (var id = 0; id < this._fileCount; id++) {
          newFileData[id] = new this._IntArray(this._filebytes);
          this._fileSaveIds.push(id);
        }
        for (var p = 0; p < this._patterncount; p++) {
          for (var f = 0; f < this._framecount; f++) {
            var id = parseInt(f / this._framesperfile);
            var pOffset = ((f - (id * this._framesperfile)) * this._patterncount + p) * this._unitsperframe;
            // console.log("pattern, frame", p, f, "id, pOffset", id, pOffset);
            if (this._unitsperframe > 1) {
              newFileData[id].set(this._livedata[p][f], pOffset);
            } else {
              newFileData[id][pOffset] = this._livedata[p][f];
            }
          }
        }

        // Now save all of this back to the server
        return await this.saveNextFile(this, newFileData);
      }
    }

    class PwmPixels extends RgbPixels {
      constructor(patterncount, frames, framesperfile) {
        super(patterncount, frames, framesperfile);
        this._type = PWM;
        this._unitsperframe = 1;
        this._filebytes = this._framesperfile * this._patterncount * this._unitsperframe;
        this._IntArray = Uint16Array;
      }

      _blankPixel() {
        // Returns a new instance of a "blank" pixel, overridden in child classes
        return 0;
      }

      initPixels() {
        for (var p = 0; p < this._patterncount; p++) {
          this._livedata[p] = new this._IntArray(this._framecount);
        }
      }
    }

    const NO_PATTERN = 255;
    class LedAssignments {
      constructor() {
        // This requires hwsetup to be loaded before getting created
        this._colors = { "rgb": new Uint8Array(3 * getTotalLedCount(RGB)), "pwm": new Uint16Array(getTotalLedCount(PWM)) };
        this._patterns = { "rgb": new Uint8Array(getTotalLedCount(RGB)), "pwm": new Uint8Array(getTotalLedCount(PWM)) };
        // Set all patterns to no pattern initially
        for (var type of [RGB, PWM]) {
          for (var i = 0; i < this._patterns[type].length; i++) {
            this._patterns[type][i] = NO_PATTERN;
          }
        }
        this._SrcFileDetails = [
          { "name": "colorrgb.dat", "type": Uint8Array, "dest": this._colors[RGB] },
          { "name": "colorpwm.dat", "type": Uint16Array, "dest": this._colors[PWM] },
          { "name": "patternrgb.dat", "type": Uint8Array, "dest": this._patterns[RGB] },
          { "name": "patternpwm.dat", "type": Uint8Array, "dest": this._patterns[PWM] },
        ]
      }

      getDefaultColor(type, led) {
        // Returns the default colour for the given pixel, in either hex or an integer
        if (type === RGB) {
          var i = led * 3;
          var colarray = this._colors[RGB].slice(i, i + 3);
          return pixelArrayToHex(colarray);
        } else {
          return this._colors[PWM][led];
        }
      }

      setDefaultColour(type, led, color) {
        if (type === RGB) {
          var colarray = pixelHexToArray(color);
          this._colors[RGB].set(colarray, led * 3);
        } else {
          this._colors[PWM][led] = color;
        }
      }

      getAssignedPattern(type, led) {
        var pattern = this._patterns[type][led];
        if (pattern === NO_PATTERN) {
          pattern = null;
        }
        return pattern;
      }

      setAssignedPatterns(type, led, pattern) {
        if (typeof pattern !== "number") {
          pattern = NO_PATTERN;
        }
        this._patterns[type][led] = pattern;
      }

      loadFile(dets) {
        return fetch(dets.name, FETCH_NO_CACHE)
          .then(function (response) {
            return response.arrayBuffer();
          })
          .then(function (buf) {
            var arr = new dets.type(buf);
            dets.dest.set(arr.slice(0, dets.dest.length));
          });
      }

      async loadFiles(progressCallback) {
        var i = 0;
        for (var fdetail of this._SrcFileDetails) {
          await this.loadFile(fdetail);
          i++;
          progressCallback(i, this._SrcFileDetails.length);
        }
      }

      saveFile(dets) {
        var formData = new FormData();
        formData.append('data', new Blob([dets.dest.buffer]), dets.name);
        return fetch('edit', {
          method: "POST",
          body: formData
        })
          .then(function (resp) {
            if (resp.ok) {
              return;
            } else {
              // There was some error - log it and try again in a second
              console.error("Error saving file:", resp, dets.name);
              showAlert("Error saving LED file (" + dets.name + "): " + resp.statusText, "savepattern");
            }
          })
          .catch(function (error) {
            console.error("Major Error:", error);
            showAlert("Network error saving LED file (" + dets.name + "): " + resp.statusText, "savepattern");
          });
      }

      async saveFiles(progressCallback) {
        var i = 0;
        for (var fdetail of this._SrcFileDetails) {
          await this.saveFile(fdetail);
          i++;
          progressCallback(i, this._SrcFileDetails.length);
        }
      }

      getForJSON() {
        // Returns the data to allow saving to JSON (requires usage of the jsonReplacer)
        var ret = {};
        ret.patterns = this._patterns;
        ret.colors = this._colors;
        return ret;
      }

      setForJSON(data) {
        for (var type of [RGB, PWM]) {
          this._patterns[type].set(data.patterns[type]);
          this._colors[type].set(data.colors[type]);
        }
      }
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function jsonReplacer(key, value) {
      // Detects TypedArrays, and converts them to JS arrays so they are
      // stringified correctly.
      if (value && typeof value.BYTES_PER_ELEMENT === "number") {
        return Array.from(value);
      }
      return value;
    }

    function setupPage() {
      // Called onLoad is complete
      $('#modalEditPattern').on('hide.bs.modal', function (e) {
        playPattern(false);
        renderAllPatterns();
      })
      $(modalBulkUpload).on('show.bs.modal', updateBulkDimensions);
    }

    async function getConfig() {
      return await fetch('config').
        then(function (response) {
          return response.json();
        })
        .then(function (response) {
          activeconfig = response;
          return Promise.resolve();
        })
        .catch(error => console.error(error));
    }

    function sliderDrag(v) {
      v.target.previousSibling.style.backgroundColor = backgroundForBrightness(v.value);
    }

    function backgroundForBrightness(val) {
      var colorpcg = val / 4095 * 255;
      var color = "rgb(" + colorpcg + "," + colorpcg + "," + colorpcg + ")"
      return color;
    }

    function makeBrightnessSlider(id, e) {
      var val = editingInfo[id];
      if (val === undefined) {
        val = 0xfff / 2;
      }
      var span = $("<span style='margin-left: 0.5em;'></span>");
      var input = $("<input style = 'max-width: 4em; margin-left: 0.5em;' id='" + id + "' />");
      span.append(input);
      var x = input.slider({ 'type': 'text', 'min': 0, 'max': 4095, 'step': 1, 'value': val })
        .on("slide", sliderDrag)
        .on("slideStop", sliderDrag);
      x[0].previousSibling.style.backgroundColor = backgroundForBrightness(val);
      input.show();

      $(e).append(span);
      // Now it's attached, get the real input element
      var htmlinput = e.getElementsByTagName("input")[0];
      htmlinput.jsslider = input;
      htmlinput.setValue = function (v) {
        this.jsslider.slider("setValue", v);
      }
    }

    function makeColorPicker(id, e) {
      var val = editingInfo[id];
      if (val === undefined) {
        val = "FF0000";
      }
      var input = document.createElement("input");
      input.id = id;
      input.value = val;
      input.classList.add("jscolor");
      var picker = new jscolor(input, JSCOLOR_DEFAULTS);
      input.jscolor = picker;
      input.setValue = function (v) {
        this.jscolor.fromString(v);
      }
      e.appendChild(input);
    }

    function setColor(led, color) {
      ws.send(COLOR_UPDATE + JSON.stringify({ "led": led, "color": color }, jsonReplacer));
    }

    function resetIdentifyButtons() {
      $(".identify-btn").text("Identify");
    }

    var identifyTimer = null;
    function identify(e) {
      var ledinfo = myLedInfo(e);
      fetch('identify?led=' + ledinfo.led + "&ledtype=" + ledinfo.type)
        .then(function (response) {
          return response.text();
        })
        .then(function (text) {
          if (identifyTimer) {
            window.clearTimeout(identifyTimer);
          }
          resetIdentifyButtons();
          if (text == "OK") {
            e.innerText = "Activated!";
          }
          else {
            e.innerText = "Error: " + text;
          }
          identifyTimer = window.setTimeout(resetIdentifyButtons, 10000);
        })
        .catch(error => console.error(error));
    }

    function titleUpdated(e) {
      var title = e.value;
      metadata['title'] = title;
      document.title = "Lights! " + title;
      stateChanged();
    }

    function stateChanged(assignments = false, savehwsetup = false) {
      btnSaveChanges.style.display = "";
      if (assignments) {
        extraStateChanges.assignments = true;
      }
      if (savehwsetup) {
        extraStateChanges.hwsetup = true;
        btnSaveChanges.innerText = "Save Changes, Reboot & Reload";
      }
    }

    function brightness(c) {
      // Returns brightnes, 0-203.975
      if (c) {
        var c = c.substring(1);      // strip #
        var rgb = parseInt(c, 16);   // convert rrggbb to decimal
        var r = (rgb >> 16) & 0xff;  // extract red
        var g = (rgb >> 8) & 0xff;  // extract green
        var b = (rgb >> 0) & 0xff;  // extract blue

        var luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709

        return luma;
      } else {
        return 200;
      }
    }

    async function getMetadata() {
      return await getFile('metadata.json')
        .then(function (response) {
          try {
            metadata = JSON.parse(response);
          } catch (e) {
            metadata = {};
          }
          if (!metadata.lastchange) metadata.lastchange = new Date().toString();
          if (!metadata[RGB]) metadata[RGB] = [];
          if (!metadata[PWM]) metadata[PWM] = [];
          if (!metadata["leds"]) metadata["leds"] = { "rgb": [], "pwm": [] };
        });
    }

    function saveMetadata() {
      metadata.lastchange = new Date().toString();
      return setFile('metadata.json',
        JSON.stringify(metadata, jsonReplacer),
        null,
        function err(msg) {
          saveallerror = true;
          showAlert(msg, "metadata");
        }
      );
    }

    async function getHwsetup() {
      return await getFile('hwsetup.json')
        .then(function (response) {
          try {
            hwsetup = JSON.parse(response);
          } catch (e) {
            hwsetup = {};
          }
          if (!hwsetup[RGB]) hwsetup[RGB] = [];
          if (!hwsetup[PWM]) hwsetup[PWM] = [];
          if (!hwsetup['patterns']) hwsetup['patterns'] = { "rgb": 5, "pwm": 5 };
          if (!hwsetup['frames']) hwsetup['frames'] = { "count": 1500, "framespersec": 25 };
          renderHwsetup();
        });
    }

    function saveHwsetup() {
      btnSaveHwsetup.disabled = true;
      spnrSaveHwsetup.style.display = "";
      return setFile('hwsetup.json',
        JSON.stringify(hwsetup, jsonReplacer),
        function ok() {
          // Next reboot the chip if needed, and then reload the browser
          fetch("reboot", { method: "POST", })
            .then(function (resp) {
              reloadWhenBack();
            })
            .catch(function () {
              // Reload even on error, as the chip probably restarted causing the error
              reloadWhenBack();
            });
        },
        function err(msg) {
          saveallerror = true;
          showAlert(msg, "hwsetup");
          btnSaveHwsetup.disabled = false;
        }
      );
    }

    function reloadWhenBack() {
      // Runs forever waiting for the chip to come back,
      // and will then reload the page
      setTimeout(reloadWhenBackAction, 1000);
    }

    function reloadWhenBackAction() {
      fetch("config")
        .then(function (response) {
          console.log("reload /config response", response.ok, response.statusText);
          if (response.ok) {
            window.location.reload();
          } else {
            reloadWhenBack();
          }
        })
        .catch(function (error) {
          console.log("reload /config error", error);
          reloadWhenBack();
        })
    }

    function genFormInputRow(label, e, helptxt) {
      // Generates a Bootstrap form input div element, with the optional helptxt
      var div = ce("div");
      div.classList.add("form-group");
      div.classList.add("row");
      var lbl = ce("label");
      if (e.id) {
        lbl.for = e.id;
      }
      lbl.classList.add("col");
      lbl.classList.add("col-form-label");
      lbl.appendChild(ct(label));
      div.appendChild(lbl);
      var divinp = ce("div");
      divinp.classList.add("col");
      divinp.appendChild(e);
      e.classList.add("form-control");
      div.appendChild(divinp);
      // XXX helptxt
      return div;
    }

    function hwdevData(e) {
      // For a given div with the relevant dataset, extracts the current
      // set and limits
      var ret = {};
      ret.devicetype = e.dataset.ledconfig;
      ret.maxdevices = parseInt(e.dataset.maxdevices)
      ret.maxperdevice = parseInt(e.dataset.maxperdevice);
      ret.current = [];
      if (hwsetup[ret.devicetype]) {
        ret.current = hwsetup[ret.devicetype];
      }
      return ret;
    }

    function hwsetupInputChange(evt) {
      // Called when ever one of the HW setup Inputs is changed
      var ths = evt.target;
      var e = $(ths).closest("div[data-ledconfig]")[0];
      var d = hwdevData(e);
      if (ths.tagName == "SELECT") {
        var newcurrent = [];
        for (var i = 0; i < parseInt(ths.value); i++) {
          if (d.current[i]) {
            newcurrent.push(d.current[i]);
          } else {
            newcurrent.push(0);
          }
        }
        hwsetup[d.devicetype] = newcurrent;
      } else if (this.tagName == "INPUT") {
        var val = parseInt(ths.value);
        if (val < 0) {
          val = 0;
        } else if (val > d.maxperdevice) {
          val = d.maxperdevice;
        }
        hwsetup[d.devicetype][ths.name] = val;
      }
      renderHwsetup();
      btnSaveHwsetup.style.display = "";
    }

    function hwsetupPatternChange(ths) {
      // Called when ever one of the pattern Inputs is changed
      var type = ths.dataset.type;
      if (ths.checkValidity()) {
        hwsetup['patterns'][type] = parseInt(ths.value);
        btnSaveHwsetup.style.display = "";
        renderHwsetup();
      }
    }

    function hwsetupFramesChange(e) {
      var item = e.dataset.item;
      hwsetup.frames[item] = parseInt(e.value);
      renderHwsetup();
      btnSaveHwsetup.style.display = "";
    }

    function renderHwsetup() {
      // Get all of the hardware device types:
      for (var e of $("div[data-ledconfig]")) {
        var d = hwdevData(e);
        e.innerHTML = '';
        var sel = ce("select");
        sel.name = "devicecount";
        sel.onchange = hwsetupInputChange;
        for (var i = 0; i <= d.maxdevices; i++) {
          var opt = ce("option");
          opt.innerText = i;
          opt.value = i;
          if (d.current.length == i) {
            opt.selected = true;
          }
          sel.appendChild(opt);
        }
        e.appendChild(genFormInputRow("Number of strips:", sel));
        renderHwsetupInputs(sel);
      }
      inpNumRGBPatterns.value = hwsetup['patterns'][RGB];
      inpNumPWMPatterns.value = hwsetup['patterns'][PWM];
      inpFramesCount.value = hwsetup.frames.count;
      inpFrameRate.value = hwsetup.frames.framespersec;
      inpFramesDuration.value = hwsetup.frames.count / hwsetup.frames.framespersec + " seconds"

      // Calculate storage requirements
      // Total number of frames * 3 bytes for RGB and 2 bytes for PWM
      var storage = hwsetup.frames.count * (hwsetup.patterns.rgb * 3 + hwsetup.patterns.pwm * 2);
      // plus 380 bytes per item for metadata for each pattern
      storage += 380 * (hwsetup.patterns.rgb + hwsetup.patterns.pwm);
      // 1 byte for the pattern allocation, plus 3 bytes for the default colour, plus about 80 bytes for the metadata
      storage += getTotalLedCount(RGB) * (1 + 3 + 80);
      // 1 byte for the pattern allocation, plus 2 bytes for the default colour, plus about 80 bytes for the metadata
      storage += getTotalLedCount(PWM) * (1 + 2 + 80);
      // Fixed approx number of bytes for the hwsetup JSON and this HTML
      storage += 100 + 90000;
      // Plus a block (8k per block - roughly) for each file
      storage += 8000 * (6 + (hwsetup.frames.count / FRAMES_PER_FILE) * 2);
      inpTotalStorage.value = renderKB(storage);
      if (storage >= activeconfig.total) {
        inpTotalStorage.classList.add("text-danger");
      }
      else {
        inpTotalStorage.classList.remove("text-danger");
      }
    }

    function renderHwsetupInputs(t) {
      var e = $(t).closest("div[data-ledconfig]")[0];
      var d = hwdevData(e);
      var loopmax = d.current.length;
      if (d.maxdevices < loopmax) {
        loopmax = d.maxdevices;
      }
      for (var i = 0; i < loopmax; i++) {
        var inp = ce("input");
        inp.type = "number";
        inp.max = d.maxperdevice;
        inp.min = 0;
        inp.name = i;
        inp.value = d.current[i];
        inp.onchange = hwsetupInputChange;
        e.appendChild(genFormInputRow("Count for " + i + ": ", inp));
      }
    }

    function getFile(filename) {
      return fetch(filename, FETCH_NO_CACHE).
        then(function (response) {
          return response.text();
        })
        .catch(error => console.error("Error getting file:", error));
    }

    function setFile(filename, datastr, completefunc, errorfunc) {
      var formData = new FormData();
      formData.append('data', new Blob([datastr]), filename);
      return fetch('edit', {
        method: "POST",
        body: formData
      })
        .then(function (res) {
          if (res.ok) {
            if (completefunc) {
              completefunc();
            }
          } else {
            if (errorfunc) {
              errorfunc("Error Response: " + res.statusText);
            }
          }
        })
        .catch(function (error) {
          console.error("setFile Error:", error);
          if (errorfunc) {
            errorfunc("Network error: " + error);
          }
        });
    }

    function loadData() {
      newProgress("Loading...", "Metadata");
      updateProgress(1, 100);
      dOverallProgressBar.style.width = '5%';
      getConfig()
        .then(getMetadata)
        .then(getHwsetup)
        .then(dataUpdate)
        .then(function () {
          dOverallProgressBar.style.width = '10%';
          if (!rgbs) {
            rgbs = new RgbPixels(hwsetup.patterns.rgb, hwsetup.frames.count, FRAMES_PER_FILE);
          }
          if (!pwms) {
            pwms = new PwmPixels(hwsetup.patterns.pwm, hwsetup.frames.count, FRAMES_PER_FILE);
          }
          if (!ledAssignments) {
            ledAssignments = new LedAssignments();
          }
          return Promise.resolve();
        })
        .then(function () {
          newProgress(null, "LED Assignments");
          return ledAssignments.loadFiles(updateProgress);
        })
        .then(function () {
          newProgress(null, "RGB Patterns");
          return rgbs.loadFiles(updateProgress);
        })
        .then(function () {
          dOverallProgressBar.style.width = '55%';
          newProgress(null, "PWM Patterns");
          return pwms.loadFiles(updateProgress);
        })
        .then(function () {
          dOverallProgressBar.style.width = '95%';
        })
        .then(function () {
          dOverallProgressBar.style.width = '100%';
        })
        .then(function () {
          renderAllPatterns();
        })
        .then(function () {
          renderAllLeds();
        })
        .then(function () {
          $(dProgressArea).collapse("hide");
        });
    }

    function renderKB(val) {
      var txt = val;
      if (txt.toFixed) {
        txt = txt / 1000;
        txt = Math.round(txt);
        txt = txt.toLocaleString();
        txt += "kB";
      }
      return txt;
    }

    function dataUpdate() {
      // items that have a byte count, to be converted to KB
      const datatypes = new Set(["heap", "total", "used", "free", "flashrealsize"]);
      for (var k of ["heap", "ssid", "version", "extrasversion", "total", "used", "free", "flashrealsize"]) {
        var txt = activeconfig[k];
        if (datatypes.has(k)) {
          txt = renderKB(txt);
        }
        document.getElementById(k).innerText = txt;
      }

      var title = metadata['title'];
      if (title) {
        document.title = "Lights! " + title;
        document.getElementById("title").innerText = title;
      }
    }

    // Websocket Stuff
    var ws = null;
    function ge(s) { return document.getElementById(s); }
    function ce(s) { return document.createElement(s); }
    function ct(s) { return document.createTextNode(s); }
    function sendBlob(str) {
      var buf = new Uint8Array(str.length);
      for (var i = 0; i < str.length; ++i) buf[i] = str.charCodeAt(i);
      ws.send(buf);
    }

    function startSocket() {
      // ws = new WebSocket('ws://' + document.location.host + '/ws', ['lights']);
      // XXX We may need the "protocol" . lights above  for things to work
      ws = new WebSocket('ws://' + document.location.host + '/ws');
      ws.binaryType = "arraybuffer";
      ws.onopen = function (e) {
        console.log("Connected");
      };
      ws.onclose = function (e) {
        console.log("Disconnected, will reconnect in 2 second");
        setTimeout(function () {
          startSocket();
        }, 2000);
      };
      ws.onerror = function (e) {
        console.log("WS Error", e);
        ws.close();
      };
      ws.onmessage = function (e) {
        var msg = "";
        if (e.data instanceof ArrayBuffer) {
          msg = "BIN:";
          var bytes = new Uint8Array(e.data);
          for (var i = 0; i < bytes.length; i++) {
            msg += String.fromCharCode(bytes[i]);
          }
        } else {
          msg = "TXT:" + e.data;
        }
        console.log(msg);
      };
    }

    function doTestMode(id) {
      fetch('testmode?mode=' + id)
        .then(function (response) {
          return response.text();
        })
        .then(function (text) {
          console.log("Test Mode Response:", text);
          var b = $("#btnTestModeOff");
          if (text == "OFF") {
            b.hide();
          }
          else {
            b.text("Stop Test " + text);
            b.show();
          }
        }
        )
        .catch(error => console.error(error));
    }

    function checkReload() {
      // Start a fetch connection to the /reload endpoint, which is only available
      // on the dev server - it reloads the page when changes are made to speed 
      // up development.
      console.log("Starting Debug reload fetch...");
      var starttime = new Date();
      fetch('reload').
        then(function (response) {
          console.log(response.status);
          if (response.status == 505) {
            // We got our special status code, reload
            window.location.reload();
          }
        })
        .catch(error => {
          var errortime = new Date();
          var errordelay = errortime - starttime;
          if (errordelay < 3000) {
            console.log("Error was less than 3 seconds ago, ignoring");
          } else {
            console.error("Reload Error, reload in 1 second", error, errortime - starttime);
            window.setTimeout(function () {
              window.location.reload();
            }, 1000);
          }
        });
    }

    var playPatternFrame = 0;
    var playIntervalId = null;
    function playPattern(setto) {
      if (setto === true || (setto === undefined && playIntervalId === null)) {
        editTimePointer.style.display = "";
        playPatternFrame = 0;
        playIntervalId = setInterval(updatePatternFrame, 1000 / hwsetup.frames.framespersec);
        btnEditPlay.innerHTML = PAUSE_ICON;
      } else {
        editTimePointer.style.display = "none";
        clearInterval(playIntervalId);
        playPatternFrame = 0;
        updatePatternFrame();
        playIntervalId = null;
        btnEditPlay.innerHTML = PLAY_ICON;
      }
    }

    function updatePatternFrame() {
      divPlay.style.backgroundColor = "#" + editingFunctions.toHexFunc(currentEditPattern[playPatternFrame]);
      editTimePointer.style.left = (100 * playPatternFrame / hwsetup.frames.count) + "%";
      playPatternFrame++;
      if (playPatternFrame >= hwsetup.frames.count) {
        playPatternFrame = 0;
      }
    }

    function changePatternStyle() {
      editingInfo.style = selPatternStyle.value;
      $(".card-edit").hide();
      $("#cardEdit" + editingInfo.style).show();
    }

    function patternApply() {
      // Get all colors, and update metadata
      var colors = [];
      for (var e of $("#modalEditPattern").find("div[data-colorcontrol]")) {
        var inp = $(e).find("input")[0];
        colors[inp.id] = editingFunctions.toNativeFunc(inp.value);
        // Store this to the metadat
        editingInfo[inp.id] = inp.value;
      }
      // Store any other values to the metadata
      for (var e of $("#modalEditPattern").find(".store-value")) {
        editingInfo[e.id] = e.value;
      }
      metadata[editingInfo.type][editingInfo.pattern].title = inpPatternTitle.value;
      stateChanged(true);

      if (editingInfo.style === "Static") {
        var color = colors.inpStaticColor;
        if (typeof color === "number") {
          for (var f = 0; f < hwsetup.frames.count; f++) {
            currentEditPattern[f] = color;
          }
        } else {
          // copy across a copy of each array so everything is not referencing the same pixel
          for (var f = 0; f < hwsetup.frames.count; f++) {
            currentEditPattern[f] = color.slice();
          }
        }
      }
      else if (editingInfo.style === "Flash") {
        var flashes = parseFloat(inpFlashesPerCycle.value);
        var totalFrames = parseInt(hwsetup.frames.count / flashes);
        var onFrames = parseInt(totalFrames * (parseFloat(inpFlashOnTime.value) / 100));
        var offFrames = totalFrames - onFrames;
        var flashI = parseInt(parseFloat(inpFlashOffset.value) * hwsetup.frames.framespersec);

        for (var f = 0; f < hwsetup.frames.count; f++) {
          if (flashI >= totalFrames) {
            flashI = 0;
          }
          if (flashI < offFrames) {
            currentEditPattern[f] = colors.inpFlashOffColor;
          } else {
            currentEditPattern[f] = colors.inpFlashOnColor;
          }
          flashI++;
        }
      }
      else if (editingInfo.style === "Fade") {
        var startColor = colors.inpFadeStartColor;
        var endColor = colors.inpFadeEndColor;
        var fades = parseFloat(inpFadesPerCycle.value);
        var stepsPerFade = hwsetup.frames.count / fades;
        if (editingInfo.type == RGB) {
          var blendFunc = rgbBlend;
        } else {
          var blendFunc = pwmBlend;
        }
        for (var f = 0; f < hwsetup.frames.count; f++) {
          step = f % stepsPerFade;
          pcg = step / stepsPerFade;
          if (pcg < 0.5)
            pcg = pcg * 2;
          else
            pcg = (1.0 - pcg) * 2;
          currentEditPattern[f] = blendFunc(startColor, endColor, pcg);
        }
      }
      updatePattern(editingInfo.type, editingInfo.pattern, divPatternEdit, true);
    }

    function saveAllChanges() {
      btnSaveChanges.disabled = true;
      saveallerror = false;
      newProgress("Saving...", "Metadata");
      dOverallProgressBar.style.width = '0%';
      saveMetadata()
        .then(function () {
          dOverallProgressBar.style.width = '5%';
          newProgress(null, "LED Assignments");
          return ledAssignments.saveFiles(updateProgress);
        })
        .then(function () {
          dOverallProgressBar.style.width = '10%';
          newProgress(null, "RGB Patterns");
          return rgbs.saveFiles(updateProgress);
        })
        .then(function () {
          dOverallProgressBar.style.width = '55%';
          newProgress(null, "PWM Patterns");
          return pwms.saveFiles(updateProgress);
        })
        .then(function () {
          if (extraStateChanges.assignments) {
            return fetch('assign', { method: "POST" });
          }
        })
        .then(function () {
          extraStateChanges.assignments = false;
          if (extraStateChanges.hwsetup) {
            newProgress(null, "Rebooting...");
            // This will reboot and reload the page, so don't clear the flag or the screen
            saveHwsetup();
          } else {
            dOverallProgressBar.style.width = '100%';
            // Wait a moment before hiding incase the process was too fast and the 
            // progress area is still "show"ing
            window.setTimeout(function () {
              $(dProgressArea).collapse("hide");
            }, 1000);
            btnSaveChanges.disabled = false;
            document.getElementById("btnSaveChanges").style.display = "none";
          }
        });
    }

    function todayISO() {
      var now = new Date();
      return now.getFullYear() + "-" + (now.getMonth() + 1).toFixed().padStart(2, "0") + "-" + now.getDate().toFixed().padStart(2, "0");
    }

    function deviceAsFilename() {
      var ret = metadata.title.trim();
      ret = ret.replace(" ", "_");
      for (c of "!?:/\\") {
        ret = ret.replace(c, "");
      }
      return ret;
    }

    function downloadAllPatternImage(type) {
      var thisPixels = window[type + 's'];
      tmpcanvas.width = hwsetup.frames.count;
      tmpcanvas.height = hwsetup.patterns[type];
      const ctx = tmpcanvas.getContext('2d');
      var imgData = ctx.createImageData(hwsetup.frames.count, 1);
      for (var p = 0; p < hwsetup.patterns[type]; p++) {
        var pattern = thisPixels.getPattern(p);
        generatePatternImageData(type, pattern, imgData);
        ctx.putImageData(imgData, 0, p);
      }
      tmpcanvas.toBlob(function (data) {
        var fileName = deviceAsFilename() + "_All_Patterns_" + type + "_" + todayISO() + ".png";
        downloadBlob(data, fileName);
      });
    }

    function downloadBlob(blob, fileName) {
      var url = URL.createObjectURL(blob);
      downloadlink.href = url;
      downloadlink.download = fileName;
      downloadlink.click();
    }

    function downloadFullBackup() {
      var blob = new Blob([JSON.stringify(generateFullBackup(), jsonReplacer)], { type: "application/json" });
      downloadBlob(blob, deviceAsFilename() + "_full_backup_" + todayISO() + ".json");
    }

    function generateFullBackup() {
      // Generates a giant JSON blob for backing everything up
      var backup = {};
      backup.rgbpatterns = rgbs.getForJSON();
      backup.pwmpatterns = pwms.getForJSON();
      backup.hwsetup = hwsetup;
      backup.metadata = metadata;
      backup.assignments = ledAssignments.getForJSON();
      return backup;
    }

    function restoreFullBackup(data) {
      hwsetup = data.hwsetup;
      metadata = data.metadata;
      rgbs = new RgbPixels(hwsetup.patterns.rgb, hwsetup.frames.count, FRAMES_PER_FILE);
      pwms = new PwmPixels(hwsetup.patterns.pwm, hwsetup.frames.count, FRAMES_PER_FILE);
      ledAssignments = new LedAssignments();
      rgbs.setForJSON(data.rgbpatterns);
      pwms.setForJSON(data.pwmpatterns);
      ledAssignments.setForJSON(data.assignments);
      dataUpdate();
      renderAllPatterns();
      renderAllLeds();
      stateChanged(true, true);
    }

    function downloadPatternImage() {
      editCanvas.toBlob(function (data) {
        var fileName = deviceAsFilename() + "_Pattern_" + editingInfo.type + "_" + editingInfo.pattern + "_" + todayISO() + ".png";
        downloadBlob(data, fileName);
      });
    }

    function downloadPatternJSON(style) {
      var fileName = "Pattern_" + editingInfo.type + "_" + editingInfo.pattern;
      var srcpattern = currentEditPattern;
      if (editingInfo.type === RGB) {
        if (style === "packed") {
          fileName += "_packed";
          srcpattern = new Uint8Array(3 * hwsetup.frames.count);
          for (var f = 0; f < hwsetup.frames.count; f++) {
            for (var c = 0; c < 3; c++) {
              srcpattern[f * 3 + c] = currentEditPattern[f][c];
            }
          }
        }
      }
      fileName += "_" + todayISO() + ".json";
      var blob = new Blob([JSON.stringify(srcpattern, jsonReplacer)], { type: "application/json" });
      downloadBlob(blob, fileName);
    }

    function updateBulkDimensions() {
      var type = selBulkUploadType.value;
      if (type === "backup") {
        rowBulkUploadDimensions.style.display = "none";
        return;
      } else {
        rowBulkUploadDimensions.style.display = "";
      }
      spnBulkUploadWide.innerText = "...";
      spnBulkUploadHigh.innerText = "...";
      spnBulkUploadWide.innerText = hwsetup.frames.count;
      spnBulkUploadHigh.innerText = hwsetup.patterns[type];
    }

    function uploadBulkFile() {
      var type = selBulkUploadType.value;
      divBulkUploadErrors.innerText = "";
      if (!type) {
        divBulkUploadErrors.innerText = "Select pattern type";
        return;
      }
      if (fileBulkPatterns.files.length === 0) {
        divBulkUploadErrors.innerText = "Select a file to upload";
        return;
      }
      var file = fileBulkPatterns.files[0];
      var ftypeparts = file.type.split("/");
      if (type === "backup") {
        if (ftypeparts[1] !== "json") {
          divBulkUploadErrors.innerText = "A JSON file must be selected";
          return;
        }
      } else {
        if (ftypeparts[0] !== "image") {
          divBulkUploadErrors.innerText = "An image file must be selected";
          return;
        }
      }
      var reader = new FileReader();

      if (type === "backup") {
        reader.onload = function (readerEvent) {
          try {
            var newData = JSON.parse(readerEvent.target.result);
          } catch (err) {
            divBulkUploadErrors.innerText = "Unable to parse JSON data!";
            return;
          }
          restoreFullBackup(newData);
        }
        reader.readAsText(file, "UTF-8");
      } else {
        var thisPixels = window[type + 's'];
        tmpcanvas.width = hwsetup.frames.count;
        tmpcanvas.height = hwsetup.patterns[type];

        reader.onload = function (readerEvent) {
          var image = new Image();
          image.onload = function (imageEvent) {
            const ctx = tmpcanvas.getContext('2d');
            var maxheight = hwsetup.patterns[type];
            if (image.height < maxheight) maxheight = image.height;
            ctx.drawImage(image, 0, 0);
            // The canvas now has the image, extract that line by line into the pattern, ignorning Alpha channels
            for (var p = 0; p < maxheight; p++) {
              var pattern = thisPixels.getPattern(p);
              var imgData = ctx.getImageData(0, p, hwsetup.frames.count, 1);
              imageDataToPattern(type, imgData, pattern);
            }
            stateChanged();
            renderAllPatterns();
            $(modalBulkUpload).modal("hide");
          }
          image.src = readerEvent.target.result;
        }
        reader.readAsDataURL(file);
      }
    }

    function uploadDone() {
      window.setTimeout(function () {
        btnUploadCustomFile.innerText = "Upload";
      }, 1500);
    }

    function uploadPatternFile() {
      btnUploadCustomFile.innerText = "Uploading...";
      var file = fileCustomPattern.files[0];
      var ftypeparts = file.type.split("/");
      var reader = new FileReader();
      if (ftypeparts[0] === "image") {
        reader.onload = function (readerEvent) {
          var image = new Image();
          image.onload = function (imageEvent) {
            const ctx = editCanvas.getContext('2d');
            ctx.drawImage(image, 0, 0);
            // The canvas now has the image, extract that into the pattern, ignorning Alpha channels
            var imgData = ctx.getImageData(0, 0, hwsetup.frames.count, 1);
            imageDataToPattern(editingInfo.type, imgData, currentEditPattern);
            stateChanged();
            uploadDone();
          }
          image.src = readerEvent.target.result;
        }
        reader.readAsDataURL(file);
      }
      else if (ftypeparts[1] === "json") {
        reader.onload = function (readerEvent) {
          try {
            var newData = JSON.parse(readerEvent.target.result);
          } catch (err) {
            divUploadFileType.innerHTML = '<span class="text-danger">Error: unable to parse JSON data!</span>';
            uploadDone();
            return;
          }
          if (editingInfo.type === RGB) {
            if (typeof newData[0] === 'number') {
              // Packed array, set the current pattern
              var maxf = hwsetup.frames.count;
              if (newData.length / 3 < maxf) maxf = newData.length / 3;
              for (var f = 0; f < maxf; f++) {
                for (var c = 0; c < 3; c++) {
                  currentEditPattern[f][c] = newData[f * 3 + c];
                }
              }
            }
            else {
              var maxf = hwsetup.frames.count;
              if (newData.length < maxf) maxf = newData.length;
              for (var f = 0; f < maxf; f++) {
                currentEditPattern[f].set(newData[f]);
              }
            }
          }
          else {
            // PWM
            currentEditPattern.set(newData);
          }
          updatePattern(editingInfo.type, editingInfo.pattern, divPatternEdit, true);
          stateChanged();
          uploadDone();
        }
        reader.readAsText(file, "UTF-8");
      }
      else {
        console.error("Trying to upload unknown type!");
      }
    }

    function updateSelectFileType() {
      if (fileCustomPattern.files.length === 0) {
        divUploadFileType.innerText = "";
        return;
      }
      var ftype = fileCustomPattern.files[0].type;
      var ftypeparts = ftype.split("/");
      var txt;
      var enabled = false;
      if (ftypeparts[0] === "image") {
        txt = "Image (" + ftype + ")";
        enabled = true;
      }
      else if (ftypeparts[1] === "json") {
        txt = "JSON, autodetect format (" + ftype + ")";
        enabled = true;
      }
      else {
        txt = "Unknown! (" + ftype + ")";
      }
      btnUploadCustomFile.disabled = !enabled;
      divUploadFileType.innerText = txt;
    }

    function rgbBlend(a, b, pcg) {
      var ret = new Uint8Array(3);
      for (var i = 0; i < 3; i++) {
        ret[i] = colProgress(a[i], b[i], pcg);
      }
      return ret;
    }

    function pwmBlend(a, b, pcg) {
      return parseInt(colProgress(a, b, pcg));
    }

    function colProgress(start, end, pcg) {
      var total = end - start;
      var ret = start + (total * pcg);
      return ret;
    }

    var assignInfo = {};
    function assignPattern(e) {
      var srcinfo = e.closest("div[data-type]").dataset;
      updateAssignPattern(srcinfo.type, srcinfo.pattern);
      document.getElementById(srcinfo.type.toUpperCase()).scrollIntoView();
    }

    function updateAssignPattern(type, pattern) {
      btnClickAssign.innerText = "Click LED assign: " + pattern + ": " + metadata[type][pattern].title;
      assignInfo.type = type;
      assignInfo.pattern = parseInt(pattern);
      $(btnGroupClickAssign).show();
      $("a.ledassign-" + assignInfo.type).attr("href", "#");
    }

    function changeAssignPattern(amount) {
      if (assignInfo.pattern + amount >= hwsetup.patterns[assignInfo.type]) {
        return false;
      }
      else if (assignInfo.pattern + amount < 0) {
        return false;
      }
      assignInfo.pattern += amount;
      updateAssignPattern(assignInfo.type, assignInfo.pattern);
      return true;
    }

    function stopAssignPattern() {
      assignInfo = {};
      $("a.ledassign-rgb").removeAttr("href");
      $("a.ledassign-pwm").removeAttr("href");
      $(btnGroupClickAssign).hide();
    }

    function ledAssignPattern(evt) {
      var ledInfo = myLedInfo(evt.target);
      if (assignInfo.type !== ledInfo.type) {
        return;
      }
      ledAssignments.setAssignedPatterns(ledInfo.type, ledInfo.led, assignInfo.pattern);
      if ($("input[name='rdoPatternAssignOrder']:checked").val() === "sequential") {
        if (!changeAssignPattern(1)) {
          stopAssignPattern();
        }
      }
      renderLedRow(null, ledInfo.type, ledInfo.led);
      stateChanged(true);
      return false;
    }

    var editingInfo;
    var editingFunctions = {};
    var currentEditPattern;
    var editTimePointer;
    var editCanvas;
    function editPattern(e) {
      var srcinfo = e.closest("div[data-type]").dataset;
      // See if there is an existing definition for this pattern, if so, load it up
      var metaInfo = window[srcinfo.type + "s"].getInfo(srcinfo.pattern);
      if (metaInfo.def && Object.keys(metaInfo.def).length > 0) {
        editingInfo = metaInfo.def;
        selPatternStyle.value = editingInfo.style;
      } else {
        editingInfo = {
          'type': srcinfo.type,
          'pattern': srcinfo.pattern,
        };
        metaInfo.def = editingInfo;
      }
      if (editingInfo.type == RGB) {
        editingFunctions.toHexFunc = pixelArrayToHex;
        editingFunctions.toNativeFunc = pixelHexToArray;
      } else {
        editingFunctions.toHexFunc = pixelPwmToHex;
        editingFunctions.toNativeFunc = parseInt;
      }
      inpPatternTitle.value = metadata[editingInfo.type][editingInfo.pattern].title;
      currentEditPattern = window[editingInfo.type + 's'].getPattern(editingInfo.pattern);
      // For each value we have, restore the input field in the modal
      // Do before colour controls as these will also restore values
      for (var inp of $("#modalEditPattern").find('input')) {
        if (inp.id && editingInfo[inp.id] !== undefined) {
          inp.value = editingInfo[inp.id];
        }
      }
      // Update controls based on the type
      makeColorControls($("#modalEditPattern").find("div[data-colorcontrol]"));
      updatePattern(editingInfo.type, editingInfo.pattern, divPatternEdit, true);
      editTimePointer = $(divPatternEdit).children(".timepointer")[0];
      editCanvas = $(divPatternEdit).children("canvas")[0];
      if (editingInfo.type === RGB) {
        $(".pwm-only").hide();
      } else {
        $(".rgb-only").hide();
      }
      playPattern(false);
      if (!selPatternStyle.value) {
        selPatternStyle.value = "Static";
      }
      changePatternStyle();
      updateSelectFileType();
      $("#modalEditPattern").modal("show");
    }

    function makeColorControls(elements) {
      // For a given list of elements, finds the dataset.colorcontrol items, and
      // creates the required controls based on the current editingInfo.type
      for (var e of elements) {
        e.innerHTML = '';
        if (editingInfo.type == RGB) {
          makeColorPicker(e.dataset.colorcontrol, e);
        } else {
          makeBrightnessSlider(e.dataset.colorcontrol, e);
        }
      }
    }

    function pixelHexToArray(v) {
      ret = new Uint8Array(3);
      for (var i = 0; i < 3; i++) {
        ret[i] = parseInt(v.substr(i * 2, 2), 16);
      }
      return ret;
    }

    function pixelArrayToHex(v) {
      if (!v) {
        return "000000";
      }
      var ret = '';
      for (var px of v) {
        var hex = px.toString(16).padStart(2, "0");
        ret += hex;
      }
      return ret.toUpperCase();
    }

    const PWM_TO_HEX_SCALE = 0xff / 0xfff;
    function pixelPwmToHex(v) {
      if (!v) {
        return "000000";
      }
      // Scale down to 0-255
      v *= PWM_TO_HEX_SCALE;
      var hex = parseInt(v).toString(16).padStart(2, "0");
      return hex + hex + hex;
    }

    function pixelPwmToArray(v) {
      // For a given brightness, returns the closest RGBA value array
      var ret = new Uint8ClampedArray(4);
      ret[3] = 255; // Alpha channel is always max
      if (!v) {
        return ret;
      }
      // Scale down to 0-255
      v *= PWM_TO_HEX_SCALE;
      ret[0] = v;
      ret[1] = ret[0];
      ret[2] = ret[0];
      return ret;
    }

    const PWM_8_TO_12_BIT = 0xfff / 0xff;
    function pixel8bitToPwm(v) {
      // Upscales an 8bit value to a 12bit for PWM pixels
      return v * PWM_8_TO_12_BIT
    }

    function imageDataToPattern(type, imgData, pattern) {
      if (type === RGB) {
        for (var f = 0; f < hwsetup.frames.count; f++) {
          var idx = f * 4;
          for (var c = 0; c < 3; c++) {
            pattern[f][c] = imgData.data[idx + c];
          }
        }
      } else {
        for (var f = 0; f < hwsetup.frames.count; f++) {
          pattern[f] = pixel8bitToPwm(imgData.data[f * 4]);
        }
      }
    }

    function generatePatternImageData(type, pattern, imgData) {
      // Writes the pattern to the given imgData object
      // imgData must be frames.count wide, and 1 pixel high
      if (type === RGB) {
        for (var f = 0; f < hwsetup.frames.count; f++) {
          var idx = f * 4;
          for (var c = 0; c < 3; c++) {
            imgData.data[idx + c] = pattern[f][c];
          }
          imgData.data[idx + 3] = 255; // Set alpha channel
        }
      } else {
        for (var f = 0; f < hwsetup.frames.count; f++) {
          imgData.data.set(pixelPwmToArray(pattern[f]), f * 4);
        }
      }
      return imgData;
    }

    function updatePattern(type, patternid, div, timepointer = false) {
      // Updates the display and patterns in the passed div
      var cvs = $(div).children("canvas");
      if (cvs.length == 0) {
        if (timepointer) {
          var timepointer = document.createElement("img");
          timepointer.classList.add("timepointer");
          timepointer.src = TIMEPOINTER_PNG;
          timepointer.style.display = "none";
          div.appendChild(timepointer);
        }

        cvs = document.createElement("canvas");
        cvs.width = hwsetup.frames.count;
        cvs.height = 1;
        div.appendChild(cvs);
      } else {
        cvs = cvs[0];
      }
      var thisPixels = window[type + 's'];
      var pattern = thisPixels.getPattern(patternid);

      const ctx = cvs.getContext('2d');
      var imgData = ctx.createImageData(hwsetup.frames.count, 1);
      generatePatternImageData(type, pattern, imgData);
      ctx.putImageData(imgData, 0, 0);
    }

    function updatePatternDiv(type, patternid) {
      // Like update pattern, but for the main screen, will also add in the title and action
      // buttions for each element.
      // Calls updatePattern
      var div = $("#div" + type + "Patterns > div[data-pattern='" + patternid + "']")[0];
      var d3div = d3.select(div);
      var info = window[type + 's'].getInfo(patternid);

      d3div.text(d => patternid + ": ");

      d3div.selectAll("span.title")
        .data([info.title])
        .join("span.title")
        .attr("class", "title inputfield")
        .attr("data-editable", 1)
        .attr("data-src", "metadata")
        .text(d => d);

      // Ensure there is a pattern DIV, buttons etc, updatePattern will set the attributes etc
      var divpattern = $(div).children("div.pattern");
      if (divpattern.length == 0) {
        $(div).append('<div class="float-right"><button class="btn btn-primary btn-sm" onclick="editPattern(this);">Edit</button></div>');
        $(div).append('<div class="float-right"><button class="btn btn-outline-info btn-sm mx-1" onclick="assignPattern(this);">Assign</button></div>');

        divpattern = document.createElement("div");
        divpattern.classList.add("pattern");
        div.append(divpattern);
      } else {
        divpattern = divpattern[0];
      }

      updatePattern(type, patternid, divpattern);
      // var span = div.append("span")
    }

    function renderAllPatterns() {
      for (var type of [RGB, PWM]) {
        // Clear out all existing patterns
        var eDiv = document.getElementById("div" + type + "Patterns");
        eDiv.innerHTML = '';

        var patternids = window[type + 's'].getCountingArray();

        var divs = d3.select(eDiv)
          .selectAll("div")
          .data(patternids);

        var subs = divs.join("div")
          .style("border", "")
          .attr("class", "pattern-row")
          .attr("data-type", type)
          .attr("data-pattern", d => d);

        for (var i of patternids) {
          updatePatternDiv(type, i);
        }
      }
    }

    function getTotalLedCount(type) {
      var total = 0;
      for (var count of hwsetup[type]) {
        total += count;
      }
      if (type == PWM) {
        total *= LED_PER_BOARD;
      }
      return total;
    }

    function myLedInfo(e) {
      var tr = $(e).closest("tr[data-type]")[0];
      return { type: tr.dataset.type, led: tr.dataset.led };
    }

    function renderAllLeds() {
      for (var type of [RGB, PWM]) {
        var tbody = document.getElementById(type + "body");
        tbody.innerHTML = '';

        var total = getTotalLedCount(type);
        for (var l = 0; l < total; l++) {
          var ledmeta = metadata['leds'][type][l];
          if (!ledmeta) {
            ledmeta = {};
            metadata['leds'][type][l] = ledmeta;
          }

          var row = tbody.insertRow(-1);
          renderLedRow(row, type, l, false);
        }

        if (!ledtable[type]) {
          ledtable[type] = $("#" + type + "table").DataTable({
            "paging": false,
            select: {
              style: 'multi+shift',
              selector: 'td:first-child'
            }
          });
          ledtable[type].on("select", ledRowSelect);
          ledtable[type].on("deselect", ledRowSelect);
        }

      }
    }

    function renderLedRow(row, type, led, invalidate = true) {
      if (row === null) {
        // This is an update for a known existing row
        row = $('tr[data-type=' + type + '][data-led=' + led + ']')[0];
      }
      var newCells = false;
      var cell;
      while (row.cells.length < 6) {
        newCells = true;
        row.insertCell(-1);
      }
      var ledDefaultColor = ledAssignments.getDefaultColor(type, led);
      var ledAssignedPattern = ledAssignments.getAssignedPattern(type, led);
      var ledmeta = metadata['leds'][type][led];
      row.dataset.type = type;
      row.dataset.led = led;

      // Select cell
      row.cells[0].classList.add("select-checkbox");

      // LED ID cell
      row.cells[1].innerText = led;

      // Color cell
      cell = row.cells[2];
      if (type === RGB) {
        var hexcolor = ledDefaultColor;
        var usercolor = hexcolor;
      }
      else {
        var hexcolor = pixelPwmToHex(ledDefaultColor);
        var usercolor = ledDefaultColor;
      }
      cell.style.backgroundColor = "#" + hexcolor;
      cell.innerText = usercolor;
      var textcolor = '#FFFFFF';
      if (isLight(hexcolor)) {
        textcolor = '#000000';
      }
      cell.style.color = textcolor;

      // Assigned pattern cell
      cell = row.cells[3];
      if (cell.innerHTML.length < 2) {
        var aassign = document.createElement("a");
        aassign.classList.add("ledassign-" + type);
        aassign.onclick = ledAssignPattern;
        cell.appendChild(aassign);
      } else {
        var aassign = cell.firstChild;
      }
      if (typeof ledAssignedPattern === 'number') {
        aassign.innerText = ledAssignedPattern + ": " + metadata[type][ledAssignedPattern].title;
      } else {
        aassign.innerText = "None";
      }

      // Description
      cell = row.cells[4];
      if (cell.innerHTML.length < 2) {
        var field = document.createElement('span');
        field.classList.add("inputfield");
        field.dataset.editable = "";
        field.dataset.src = "ledmetadata";
        if (ledmeta.description) {
          field.innerText = ledmeta.description;
        }
        cell.appendChild(field);
      }

      // Action buttons
      cell = row.cells[5];
      if (cell.innerHTML.length < 2) {
        $(cell).append('<button class="btn btn-sm btn-info identify-btn" onclick="identify(this);">Identify</button> ');
      }

      if (invalidate) {
        ledtable[type].row(row).invalidate();
      }
    }

    function ledRowSelect(e, dt, type, indexes) {
      var type = e.currentTarget.dataset.type;
      var rowcount = ledtable[type].rows({ selected: true }).data().length;
      if (rowcount == 0) {
        $("#btnBulkEdit" + type).hide();
      } else {
        $("#spnBulkEditCount" + type).text(rowcount);
        $("#btnBulkEdit" + type).show();
      }
    }

    function bulkEdit(type) {
      var rows = ledtable[type].rows({ selected: true }).nodes();
      var firstLed = myLedInfo(rows[0]);
      var firstLedDefaultColor = ledAssignments.getDefaultColor(type, firstLed.led);
      var firstLedPattern = ledAssignments.getAssignedPattern(type, firstLed.led);

      editingInfo = {
        'type': type,
        'pattern': null,
        'inpDefaultColor': firstLedDefaultColor
      };
      makeColorControls($("#modalBulkEditLED").find("div[data-colorcontrol]"));
      // Assign the available patterns
      var patterns = [{ "desc": "None", "val": "null" }];
      for (var d of window[type + 's'].getCountingArray()) {
        patterns.push({ "desc": d + ": " + metadata[type][d].title, "val": d });
      }
      d3.select(selBulkPattern)
        .selectAll("option")
        .data(patterns)
        .join("option")
        .attr("value", d => d.val)
        .text(d => d.desc);
      if (typeof firstLedPattern === "number") {
        selBulkPattern.value = firstLedPattern;
      } else {
        selBulkPattern.value = "null";
      }
      $("#modalBulkEditLED").modal("show");
      $("#spnBulkEditLedStats").text(rows.length.toFixed(0) + " " + type.toUpperCase());
      stateChanged(true);
    }

    function saveBulkEdit() {
      var type = editingInfo.type;
      var rows = ledtable[type].rows({ selected: true }).nodes();
      var defaultColor = inpDefaultColor.value;
      if (editingInfo.type === PWM) {
        defaultColor = parseInt(defaultColor);
      }
      var selectedPattern = selBulkPattern.value;
      if (selectedPattern === "null") {
        selectedPattern = undefined;
      } else {
        selectedPattern = parseInt(selectedPattern);
      }
      for (var i = 0; i < rows.length; i++) {
        var row = rows[i];
        var ledInfo = myLedInfo(row);
        ledAssignments.setDefaultColour(type, ledInfo.led, defaultColor);
        ledAssignments.setAssignedPatterns(type, ledInfo.led, selectedPattern);
        renderLedRow(row, type, ledInfo.led);
      }
      $("#modalBulkEditLED").modal("hide");
    }

    function isLight(val) {
      if (val.length !== 6) {
        val = pixelPwmToHex(val);
      }
      var rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        rgb[i] = parseInt(val.substring(i * 2, i * 2 + 2), 16);
      }
      return (
        0.213 * rgb[0] +
        0.715 * rgb[1] +
        0.072 * rgb[2] >
        255 / 2
      );
    };

    function updateProgress(current, total) {
      // Updates the progress bar, must be set with newProgress to be visible
      var width = current / total * 100
      dProgressBar.style.width = width + '%';
    }

    function newProgress(title, subTitle) {
      dProgressBar.style.width = '0%';
      if (title)
        hProgressTitle.innerText = title;
      if (subTitle)
        hProgressSubTitle.innerText = subTitle;
      $(dProgressArea).collapse("show");
    }

    var data = [];
    var di = 0;
    var rgbs;
    var pwms;

    function runtest() {
      setTimeout(function () {
        // newProgress("Loading Files");
        // rgbs.saveFiles(updateProgress, renderAllPatterns);
        // var e = $("div[data-type]")[0];
        // $(e).find("button").click();
      }, 1000);
    }

    function showAlert(msg, id) {
      // Shows a dismissable alert, if id is set, will assing an internal alertid
      // if that id is used again, rather than creating a new prompt, it will 
      // use the exsiting one, preventing the screen filling up with errors
      var e = document.createElement("span");
      var aidtxt = '';
      e.innerText = msg;
      console.log("ID", id);
      if (id) {
        var aid = 'alrt' + id;
        aidtxt = 'id="' + aid + '"';
        var existing = document.getElementById(aid);
        if (existing) {
          existing.innerHTML = e.innerHTML;
          return;
        }
      }
      var html = '<div class="alert alert-danger sticky-top alert-dismissible fade show" role="alert">' +
        '<span ' + aidtxt + '>' + e.innerHTML + '</span>' +
        '<button type="button" class="close" data-dismiss="alert" aria-label="Close">' +
        '<span aria-hidden="true">&times;</span>' +
        '</button> </div>';
      spanAlerts.innerHTML += html;
    }

    // started from https://stackoverflow.com/questions/33267797/turn-text-element-into-input-field-type-text-when-clicked-and-change-back-to-tex
    function invalidaterow(e) {
      // Save the value where it should go
      if (e.dataset.src === "metadata") {
        var info = e.closest("div[data-type]").dataset;
        metadata[info.type][info.pattern].title = e.value;
      }
      else if (e.dataset.src === "ledmetadata") {
        var info = myLedInfo(e);
        metadata["leds"][info.type][info.led].description = e.value;
        var tr = e.closest("tr[data-led]");
        ledtable[info.type].row(tr).invalidate();
      }
      stateChanged();
      console.log(e);
    }

    function editableblur() {
      var plain = this.parentNode.firstChild;
      plain.style.display = "";
      plain.innerText = this.value;
      this.style.display = "none";
      invalidaterow(this);
    }

    $('body').on('click', '[data-editable]', function () {
      var e = this;
      var parent = this.parentNode;
      if (!parent.dataset.editableholder) {
        var holder = document.createElement("span");
        holder.dataset.editableholder = 1;
        e.replaceWith(holder);
        holder.appendChild(e);
        e.style.display = "none";
        var input = $('<input/>').val($(e).text());
        $(holder).append(input);
        input.on('blur', editableblur)
        if (e.onchange) {
          input.on('change', e.onchange);
        }
        input.attr("data-src", e.dataset.src);
        input.focus();
      } else {
        var input = parent.lastElementChild;
        input.style.display = "";
        e.style.display = "none";
        input.value = e.innerText;
        input.focus();
      }
    });
  </script>
</body>

</html>